---
layout: post
title: Effects
date: 2019-05-20 16:01
comments: true
published: true
summary: What are effects, how do we deal with them in a referentially transparent way? This article attempts to answer that question.
tags:
    - scala
    - haskell
    - learning
    - functional
    - fp tutorial
---

It's common for people who are not very familiar with functional programming
to say that in functional programming you don't do side effects. But actually,
performing side effects, is one of strenghts of the functional approach to
programming, and it's when you have a complex enough system with lots of side
effects happening, that FP shines.

# Defininng Effects

Before we go any further, lets define effects. When we say effect in this
article, we're talking about anything that a function does that causes an
observable consequence from outside of it (other than, of course, that which
is caused by the runtime in order to run the code), or that are dependent
themselves from observing external factors. So, in languages with the
concept of class instances, or variables with a scope that escapes the closed
function, changing or reading one such variable/instance property, is an
effect. Furthermore, reading or writing from a file on disk, accessing a
database, generating a random number (unless the seed is provided to the
function), or fetching the current date/time, all are side effects.

# Pure Effects

As we [mentioned previously](/articles/Function-Properties/), there's a lot of
value to be gained from making sure our functions are pure and total. If we
just perform ad-hoc effects then, we have neither of these properties. So how
can we perform those effects then?

If you've done any _Haskell_, you've noticed how the main entry function will
have a type `IO ()` (IO of Unit). In _Scala_ similar types are provided by
libraries, amongst them are `cats.effect.IO`, `scalaz.zio.ZIO`, and
`monix.eval.Task`. These are caled Effect types, because they are types that
repesent, and allow us to perform effects in a pure way. This might sound like
a contradiction in terms, but we'll explain in a moment.

I'll be using `cats.effect.IO`, which going forward, I'll be referring to as `IO`,
to explain effects in this article, as it's the one I'm most familiar with, plus,
the fact that it is provided in a library along with the type classes and type
class instances that allow us to abstract over it makes it easier to explain
how it works.


## Referential Transparency

Let's imagine the following simple program:

```scala
import scala.util.Random

def addCharTo(s: String): String = s"${s}${Random.nextPrintableChar}"
```

When we call `addCharTo`, here's one possible result:

```scala
addCharTo("a")
// String = aF
```

Being referentially transparent, means that an expression can be replaced by
it's result value without changing the meaning of the program.
Lets see if this is true for this programme. Our call to `addCharTo`, returned
`"aF")`. If our programme is referentially transparent, then we should be able
to replace `addChar("a")` with `s"a${Random.nextPrintableChar}"` and still get
`"aF"` as a result.
Let's see what happens:

```scala
s"a${Random.nextPrintableChar}"
// String = aJ

s"a${Random.nextPrintableChar}"
// String = aY

s"a${Random.nextPrintableChar}"
// String = a^

s"a${Random.nextPrintableChar}"
// String = aT
```

Not only we didn't get `"aF"` but each time we called `s"a${Random.nextPrintableChar}"`
we got a different result. So we can say that `addChar` is not referentially
transparent, nor pure, as the reason we're losing referential Transparency
here is because the result doesn't depend exclusively on the input of the
function, but instead it depends on side effects.

Lets re-write this code using IO:

```scala
import scala.util.Random

import cats.effect.IO

def addCharTo(s: String): IO[String] = IO.delay(s"${s}${Random.nextPrintableChar}")
```

Now, when we call `addCharTo`, this is what we get:

```scala
addCharTo("a")
// cats.effect.IO[String]
```

No matter how many times we call it, we'll always get a new value of type
`IO[String]`. So now, `addCharTo` is not performing a side effect anymore, and
the return result is referentially transparent. Meaning, that we can replace
the function call with what it returns:

```scala
import scala.util.Random

import cats.effect.IO

def addCharTo(s: String): IO[String] = IO.delay(s"${s}${Random.nextPrintableChar}")

addCharTo("a")
// cats.effect.IO[String]

IO.delay(s"a${Random.nextPrintableChar}")
// cats.effect.IO[String]

```

Now `addCharTo` is pure, and referentially transparent.
At this point, you might be thinking that this doesn't look that useful, since
we got purity and referential transparency, at the cost of getting back
something that is not the result of the effect we want to perform.
This section focused purely on the mechanics of how IO works, so let's take
a look at how and why this is useful, and the reasoning behind this approach.

# Structure and Interpretation


