---
layout: post
title: Effects
date: 2019-05-20 16:01
comments: true
published: true
summary: What are effects, how do we deal with them in a referentially transparent way? This article attempts to answer that question.
tags:
    - scala
    - haskell
    - learning
    - functional
    - fp tutorial
---

It's common for people who are not very familiar with functional programming
to say that in functional programming you don't do side effects. But actually,
performing side effects, is one of strenghts of the functional approach to
programming, and it's when you have a complex enough system with lots of side
effects happening, that FP shines.

# Defininng Effects

Before we go any further, lets define effects. When we say effect in this
article, we're talking about anything that a function does that causes an
observable consequence from outside of it (other than, of course, that which
is caused by the runtime in order to run the code), or that are dependent
themselves from observing external factors. So, in languages with the
concept of class instances, or variables with a scope that escapes the closed
function, changing or reading one such variable/instance property, is an
effect. Furthermore, reading or writing from a file on disk, accessing a
database, generating a random number (unless the seed is provided to the
function), or fetching the current date/time, all are side effects.

# Pure Effects

As we [mentioned previously](/articles/Function-Properties/), there's a lot of
value to be gained from making sure our functions are pure and total. If we
just perform ad-hoc effects then, we have neither of these properties. So how
can we perform those effects then?

If you've done any _Haskell_, you've noticed how the main entry function will
have a type `IO ()` (IO of Unit). In _Scala_ similar types are provided by
libraries, amongst them are `cats.effect.IO`, `scalaz.zio.ZIO`, and
`monix.eval.Task`. These are caled Effect types, because they are types that
repesent, and allow us to perform effects in a pure way. This might sound like
a contradiction in terms, but we'll explain in a moment.

I'll be using `cats.effect.IO`, which going forward, I'll be referring to as `IO`,
to explain effects in this article, as it's the one I'm most familiar with, plus,
the fact that it is provided in a library along with the type classes and type
class instances that allow us to abstract over it makes it easier to explain
how it works.

Let's imagine the following simple program:

```scala
import scala.util.Random

def sillyFunction(s: String): String = s"$s and ${Random.nextPrintableChar}"
```

When we call `sillyFunction` twice, here are two possible results:

```scala
sillyFunction("a")
// a and F

sillyFunction("a")
// a and 7
```

We called `sillyFunction` twice, with the same input, and yet we got different
results. So much for referential transparency. For memory refreshment, being
referentially transparent, means that an expression can be replaced by it's
result value without changing the meaning of the program.
If this was true for this program, we could have replaced the call to
`sillyFunction("a")` with `"a and F"`, since that was our first result, but
turns out we can't because it would change what the second call did, which was 
returning `"a and 7"`.



